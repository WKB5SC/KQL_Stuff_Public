DeviceProcessEvents
| where InitiatingProcessFileName in~ ("dfsvc.exe", "rundll32.exe")
| where FileName endswith ".application" or ProcessCommandLine contains ".application"
| project Timestamp, DeviceName, FileName, ProcessCommandLine, InitiatingProcessFileName

DeviceProcessEvents
| where InitiatingProcessFileName =~ "dfsvc.exe" or ProcessCommandLine has ".application"
| extend AppDataPath = strcat(@"C:\Users\", AccountName, @"\AppData\Local\Apps\2.0")
| where FolderPath startswith AppDataPath
| project Timestamp, DeviceName, AccountName, FileName, ProcessCommandLine, FolderPath, InitiatingProcessFileName
| order by Timestamp desc

DeviceProcessEvents
| where ProcessCommandLine has_any ("APPDOMAIN_MANAGER_ASM", "APPDOMAIN_MANAGER_TYPE", "COMPLUS_VERSION")
| project Timestamp, DeviceName, AccountName, FileName, ProcessCommandLine, InitiatingProcessFileName
| order by Timestamp desc

DeviceNetworkEvents
| where RemoteUrl has_any ("amazonaws.com", "cloudfront.net", "lambda-url.", "execute-api.")
| where InitiatingProcessFileName in~ ("dfsvc.exe", "ZSATray.exe", "umt.exe")
| project Timestamp, DeviceName, InitiatingProcessFileName, RemoteUrl, RemoteIP, ActionType, ReportId
| order by Timestamp desc

let clickonceEvents = DeviceProcessEvents
    | where InitiatingProcessFileName =~ "dfsvc.exe" and ProcessCommandLine has ".application"
    | project DeviceId, ClickOnceTime = Timestamp, ClickOnceProc = FileName;

let awsTraffic = DeviceNetworkEvents
    | where RemoteUrl has_any ("amazonaws.com", "cloudfront.net", "lambda-url.", "execute-api.")
    | project DeviceId, NetworkTime = Timestamp, RemoteUrl, InitiatingProcessFileName;

clickonceEvents
| join kind=inner (awsTraffic) on DeviceId
| where abs(datetime_diff("minute", ClickOnceTime, NetworkTime)) < 10
| project DeviceId, ClickOnceTime, NetworkTime, ClickOnceProc, InitiatingProcessFileName, RemoteUrl

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\Security\TrustManager\PromptingLevel
Internet = Disabled

Preventing ClickOnce-based attacksâ€”like the recent OneClik campaignâ€”requires a layered defense strategy that combines system hardening, user awareness, and proactive monitoring. Hereâ€™s how to stay ahead of the threat:

---

ðŸ” 1. Harden the Environment

â€¢ Disable ClickOnce from Internet Zones
Set the following registry key to block installations from untrusted sources:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\Security\TrustManager\PromptingLevel
Internet = DisabledThis prevents users from being prompted to install ClickOnce apps from the web A.
â€¢ Restrict ClickOnce Usage
If your organization doesnâ€™t rely on ClickOnce, consider disabling it entirely via Group Policy or endpoint management tools.
â€¢ Enforce Code Signing
Require all ClickOnce apps to be signed with trusted certificates. Unsigned or self-signed apps should be blocked or flagged B.


---

ðŸ§  2. Educate and Empower Users

â€¢ Phishing Awareness
Train users to recognize suspicious links and popups, especially those prompting software installs from unfamiliar domains.
â€¢ Visual Cues
Teach users to inspect the ClickOnce install dialogâ€”malicious apps often spoof names like â€œWindows Updateâ€ or use misleading domains C.


---

ðŸ•µï¸â€â™‚ï¸ 3. Monitor and Detect

â€¢ Baseline Legitimate ClickOnce Activity
Understand which apps are deployed via ClickOnce in your environment. Anything outside that baseline is suspicious.
â€¢ Hunt for Known Abuse Patterns
Use Defender KQL queries to detect:â€¢ `dfsvc.exe` launching `.application` files
â€¢ AppDomainManager injection
â€¢ AWS-based C2 traffic from unexpected processes

â€¢ Log and Alert on Rundll32 Abuse
Monitor for commands like:rundll32.exe dfshim.dll,ShOpenVerbApplicationwhich can be used to stealthily launch ClickOnce payloads A.


---

ðŸ§° 4. Use Trusted App Deployment Policies

â€¢ Trusted Publisher Certificates
Configure enterprise-wide trusted publishers so only vetted ClickOnce apps can install silently B.
â€¢ Zone-Based Permissions
Limit ClickOnce permissions based on deployment source (e.g., full trust only for internal network shares).


---

Would you like help creating a Group Policy template or registry script to enforce these protections? I can also help you simulate a safe test of ClickOnce behavior in a lab environment.

Yesâ€”it absolutely does. The OneClik attack campaign relies on a `.application` file as its initial delivery mechanism A.

Hereâ€™s how it fits into the attack chain:

ðŸ§¨ Phishing + ClickOnce Abuse
Victims receive phishing emails linking to fake websites (often hosted on Microsoft Azure). These sites serve a malicious `.application` file, which is a ClickOnce deployment manifest disguised as a legitimate installer A.

ðŸš€ Execution via Trusted Binary
When the user clicks the `.application` file, it launches under `dfsvc.exe`â€”a trusted Windows binary responsible for handling ClickOnce apps. This allows the malware to:

â€¢ Bypass User Account Control (UAC)
â€¢ Avoid requiring admin privileges
â€¢ Blend in with legitimate activity A


ðŸ§¬ Payload Delivery
The `.application` file triggers a .NET-based loader (OneClikNet), which uses AppDomainManager injection to hijack the assembly loading process. This leads to the execution of a Golang-based backdoor called RunnerBeacon A.

So while the `.application` file isnâ€™t an executable itself, itâ€™s the launchpad for the entire attackâ€”making it a critical component of the OneClik threat.

Want to see how to block `.application` files from launching in your environment or simulate this behavior safely in a lab? Iâ€™ve got you covered.

Absolutely, N. Hereâ€™s a ClickOnce-focused KQL hunting pack designed to help you detect OneClik-style attacks across multiple stagesâ€”from initial execution to command-and-control (C2) activity and potential persistence.

---

ðŸ§­ 1. Detect ClickOnce Launch via `.application` Files

DeviceProcessEvents
| where ProcessCommandLine has ".application"
| where InitiatingProcessFileName in~ ("dfsvc.exe", "rundll32.exe")
| project Timestamp, DeviceName, AccountName, FileName, ProcessCommandLine, InitiatingProcessFileName

Flags ClickOnce apps launched via trusted binaries.

---

ðŸ§¬ 2. AppDomainManager Injection Indicators

DeviceProcessEvents
| where ProcessCommandLine has_any ("APPDOMAIN_MANAGER_ASM", "APPDOMAIN_MANAGER_TYPE", "COMPLUS_VERSION")
| project Timestamp, DeviceName, AccountName, FileName, ProcessCommandLine

Detects abuse of .NET AppDomainManager for stealthy payload injection.

---

â˜ï¸ 3. Suspicious AWS-Based C2 Traffic

DeviceNetworkEvents
| where RemoteUrl has_any ("amazonaws.com", "cloudfront.net", "lambda-url.", "execute-api.")
| where InitiatingProcessFileName in~ ("dfsvc.exe", "ZSATray.exe", "umt.exe")
| project Timestamp, DeviceName, RemoteUrl, InitiatingProcessFileName, RemoteIP, ActionType

Flags unexpected cloud traffic from binaries often abused in OneClik.

---

ðŸ”— 4. Correlate ClickOnce Launch with AWS C2

let clickonce = DeviceProcessEvents
    | where InitiatingProcessFileName =~ "dfsvc.exe" and ProcessCommandLine has ".application"
    | project DeviceId, ClickOnceTime = Timestamp, ClickOnceProc = FileName;

let awsC2 = DeviceNetworkEvents
    | where RemoteUrl has_any ("amazonaws.com", "cloudfront.net", "lambda-url.", "execute-api.")
    | project DeviceId, NetworkTime = Timestamp, RemoteUrl, InitiatingProcessFileName;

clickonce
| join kind=inner (awsC2) on DeviceId
| where abs(datetime_diff("minute", ClickOnceTime, NetworkTime)) < 10
| project DeviceId, ClickOnceTime, NetworkTime, ClickOnceProc, InitiatingProcessFileName, RemoteUrl

Connects ClickOnce execution with suspicious cloud traffic within a short window.

---

ðŸ§¼ 5. Detect Rundll32 Abuse for ClickOnce

DeviceProcessEvents
| where InitiatingProcessFileName =~ "rundll32.exe"
| where ProcessCommandLine has "dfshim.dll,ShOpenVerbApplication"
| project Timestamp, DeviceName, AccountName, ProcessCommandLine

Identifies stealthy ClickOnce launches via `rundll32`.

---

ðŸ§¾ 6. Detect Unsigned or Rare ClickOnce Apps

DeviceProcessEvents
| where ProcessCommandLine has ".application"
| extend Signer = tolower(SignerName)
| where isnull(Signer) or Signer !contains "microsoft"
| summarize count() by FileName, Signer, AccountName, DeviceName

Flags unsigned or unusually signed ClickOnce manifests.

---

Would you like me to bundle these into a workbook or Sentinel hunting rule format? I can also help you simulate benign ClickOnce activity to baseline your environment.

let clickonce = DeviceProcessEvents
    | where InitiatingProcessFileName =~ "dfsvc.exe"
    | where ProcessCommandLine has ".application"
    | project DeviceId, ClickOnceTime = Timestamp, AccountName, FileName, ProcessCommandLine;

let awsC2 = DeviceNetworkEvents
    | where RemoteUrl has_any ("amazonaws.com", "cloudfront.net", "lambda-url.", "execute-api.")
    | where InitiatingProcessFileName in~ ("dfsvc.exe", "ZSATray.exe", "umt.exe")
    | project DeviceId, NetworkTime = Timestamp, RemoteUrl, InitiatingProcessFileName;

clickonce
| join kind=inner (awsC2) on DeviceId
| where abs(datetime_diff("minute", ClickOnceTime, NetworkTime)) < 10
| project DeviceId, ClickOnceTime, NetworkTime, AccountName, ClickOnceBinary = FileName, CommandLine = ProcessCommandLine, AWS_URL = RemoteUrl, C2Process = InitiatingProcessFileName




To detect AppDomainManager injection (your #2) using Microsoft Defender and KQL, youâ€™ll want to focus on how attackers manipulate environment variables or `.config` files to hijack .NET application behavior. Hereâ€™s a focused KQL query pack to help you uncover this stealthy technique:

---

ðŸ§¬ 1. Detect Suspicious Environment Variables

Attackers often set variables like `APPDOMAIN_MANAGER_ASM` or `APPDOMAIN_MANAGER_TYPE` to hijack .NET execution flow.

DeviceProcessEvents
| where ProcessCommandLine has_any ("APPDOMAIN_MANAGER_ASM", "APPDOMAIN_MANAGER_TYPE", "COMPLUS_VERSION")
| project Timestamp, DeviceName, AccountName, FileName, ProcessCommandLine, InitiatingProcessFileName
| order by Timestamp desc

---

ðŸ§¾ 2. Detect `.exe.config` File Drops

Malicious `.config` files can be used to inject AppDomainManager logic into trusted binaries.

DeviceFileEvents
| where FileName endswith ".exe.config"
| where ActionType == "FileCreated"
| project Timestamp, DeviceName, FileName, FolderPath, InitiatingProcessFileName

---

ðŸ” 3. Look for Matching `.exe` and `.exe.config` Pairs

This flags when a config file is dropped alongside a matching executableâ€”often a sign of hijack setup.

let exeFiles = DeviceFileEvents
    | where FileName endswith ".exe"
    | extend BaseName = tostring(split(FileName, ".")[0])
    | project DeviceId, FolderPath, BaseName, ExeTime = Timestamp;

let configFiles = DeviceFileEvents
    | where FileName endswith ".exe.config"
    | extend BaseName = tostring(split(FileName, ".")[0])
    | project DeviceId, FolderPath, BaseName, ConfigTime = Timestamp;

exeFiles
| join kind=inner (configFiles) on DeviceId, FolderPath, BaseName
| where abs(datetime_diff("minute", ExeTime, ConfigTime)) < 10
| project DeviceId, FolderPath, BaseName, ExeTime, ConfigTime

---

ðŸ§  Bonus Tip

If you know the name of the injected AppDomainManager class or DLL, you can also hunt for it in `DeviceImageLoadEvents` or `DeviceProcessModuleEvents`.

Would you like to wrap this into a Sentinel workbook or add anomaly scoring to reduce false positives? I can help you take it even further.

